{"pageProps":{"post":{"slug":"2019-03-08-unionfind","title":"UnionFind","categories":["Competitive Programming"],"image":"https://koka831.github.io/img/icon.png","tags":["Graph","TODO"],"content":"<p><a href=\"https://atcoder.jp/contests/abc120\" rel=\"nofollow\">AtCoder Beginners Contest 120</a> で連結成分のsizeを計算するdisjoint-setの問題が出題された.\nそれまでrankを用いたUnion-Findしか経験がなかったので, この機会にまとめる.</p>\n<h2 id=\"union-find\"><a href=\"#union-find\">Union-Find</a></h2>\n<p>Union-Findは要素が同一の集合に含まれるかどうかを判定するデータ構造.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>Query</th><th>Process</th></tr></thead><tbody><tr><td>unite(x, y)</td><td>X(x <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∈</mo></mrow><annotation encoding=\"application/x-tex\">\\in</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">∈</span></span></span></span> X)とY(y <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>∈</mo></mrow><annotation encoding=\"application/x-tex\">\\in</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">∈</span></span></span></span> Y)をマージする</td></tr><tr><td>same(x, y)</td><td>X == Y か判定する</td></tr></tbody></table>\n<p>の操作を</p>\n<p>各要素を1つのノード, 集合を木と表現する.\n要素が同一の集合に含まれる場合, それらの要素は同一の木のノードである.</p>\n<p>上記操作をならし計算量<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>α</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\alpha(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">))</span></span></span></span>で行う<sup><a href=\"#user-content-fn-1\" id=\"user-content-fnref-1\" data-footnote-ref=\"\" aria-describedby=\"footnote-label\">1</a></sup>ためのマージ戦略が以下の経路圧縮とrankである.</p>\n<h3 id=\"経路圧縮\"><a href=\"#経路圧縮\">経路圧縮</a></h3>\n<p>要素が同一の木のノードであるか判定する場合, 各要素のrootが同一かどうか見ればよい.\nただその場合木の高さだけ再帰的に親ノードを辿る必要がある.<br>\nそこで, 親ノードを調べる際に調べたノードをrootに直接つなぎ直すことで,次回以降の判定時の計算量を<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>に削減する.</p>\n<h3 id=\"rank\"><a href=\"#rank\">Rank</a></h3>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>e</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">unite()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">ni</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span>操作時に木の高さが高い方を親として, 低い方を高い方に繋げるようにする.</p>\n<p>ここで, 経路圧縮と併用する場合には圧縮前の高さでrankを持つ必要がある.\n経路圧縮は<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>d</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">find()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">in</span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span>操作時に行うため, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>e</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">unite()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">ni</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span>の段階では必ずしも木の高さが<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span>となっている保証はない.</p>\n<details>\n<summary>以下は経路圧縮のみの実装例.</summary>\n<div>\n<div class=\"remark-highlight\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">UnionFind</span> <span class=\"token punctuation\">{</span>\n  par<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Vec</span><span class=\"token operator\">&#x3C;</span><span class=\"token keyword\">usize</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">UnionFind</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">new</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">:</span> <span class=\"token keyword\">usize</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token keyword\">Self</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">UnionFind</span> <span class=\"token punctuation\">{</span>\n      par<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">..</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">unite</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&#x26;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">:</span> <span class=\"token keyword\">usize</span><span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">:</span> <span class=\"token keyword\">usize</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> px <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> py <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> px <span class=\"token operator\">==</span> py <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>par<span class=\"token punctuation\">[</span>py<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> px<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">same</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&#x26;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">:</span> <span class=\"token keyword\">usize</span><span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">:</span> <span class=\"token keyword\">usize</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token keyword\">bool</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">find</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&#x26;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">:</span> <span class=\"token keyword\">usize</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token keyword\">usize</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>par<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> x <span class=\"token punctuation\">{</span> x <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 経路圧縮</span>\n      <span class=\"token keyword\">let</span> p <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>par<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>par<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>par<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n</div>\n</details>\n<h2 id=\"decayed-bridges\"><a href=\"#decayed-bridges\"><a href=\"https://atcoder.jp/contests/abc120/tasks/abc120_d\" rel=\"nofollow\">Decayed Bridges</a></a></h2>\n<p>本題.</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>頂点<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span>辺の無向単純グラフの辺<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>∈</mo><mi>M</mi></mrow><annotation encoding=\"application/x-tex\">i \\in M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6986em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">∈</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span></span></span>を順番に取り除いたとき, 時刻<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>でアクセスできない頂点が何組あるか.</p>\n<h3 id=\"かんがえたこと\"><a href=\"#かんがえたこと\">かんがえたこと</a></h3>\n<p>Union-Findでは要素を統合することはできても分割操作は行えない.\n辺を除去する操作を考える場合にはグラフ全体を保持する必要が出てきてしまう. でも<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo separator=\"true\">,</mo><mi>m</mi><mo>≤</mo><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding=\"application/x-tex\">n, m \\leq 10^5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8304em;vertical-align:-0.1944em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">5</span></span></span></span></span></span></span></span></span></span></span>で隣接グラフを持つのはエグいし連結判定が厳しい.</p>\n<p>では操作を巻き戻すとどうなるかを考えた.</p>\n<p>まず辺をすべて取り除いた状態から開始し，辺を追加していく.<br>\nこのアプローチならUnion-Findで管理できる.</p>\n<p>辺を追加することで<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span>頂点と<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>頂点が新たに連結されたとすると, アクセスできる頂点ペアは<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo>∗</mo><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">a * b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4653em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>個増える.\nこの連結された頂点の増加判定は<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">same</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">am</span><span class=\"mord mathnormal\">e</span></span></span></span>操作を<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">unite</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">ni</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span></span></span></span>操作の前後に行うことで行える.</p>\n<p>が, Union-Findで集合の要素数を持つケースを初めて見たのでやや手間取った. 本番では構造体に要素数<code>siz</code>を<code>Vec</code>で保持させて<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding=\"application/x-tex\">unite</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6595em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">ni</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span></span></span></span>時に更新してなんとかなった.</p>\n<div class=\"remark-container info\"><div class=\"remark-container__title\">追記</div><p>この辺が存在した場合の連結する頂点数を考えると, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>∗</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n * (n - 1) / 2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4653em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">/2</span></span></span></span>なのでここから引いてくと楽.</p></div>\n<details>\n<summary>解答</summary>\n<div>\n<div class=\"remark-highlight\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token function\">read</span><span class=\"token punctuation\">::</span><span class=\"token operator\">&#x3C;</span><span class=\"token keyword\">usize</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> ab <span class=\"token operator\">=</span> <span class=\"token class-name\">Vec</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token number\">0</span><span class=\"token punctuation\">..</span>m <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token function\">read</span><span class=\"token punctuation\">::</span><span class=\"token operator\">&#x3C;</span><span class=\"token keyword\">usize</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        ab<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> uf <span class=\"token operator\">=</span> <span class=\"token class-name\">UnionFind</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> cost <span class=\"token operator\">=</span> n <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> ans <span class=\"token operator\">=</span> <span class=\"token class-name\">Vec</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token keyword\">in</span> ab<span class=\"token punctuation\">.</span><span class=\"token function\">into_iter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">rev</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        ans<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>cost<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> uf<span class=\"token punctuation\">.</span><span class=\"token function\">same</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">let</span> pa <span class=\"token operator\">=</span> uf<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">let</span> pb <span class=\"token operator\">=</span> uf<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">let</span> c <span class=\"token operator\">=</span> uf<span class=\"token punctuation\">.</span>siz<span class=\"token punctuation\">[</span>pa<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> uf<span class=\"token punctuation\">.</span>siz<span class=\"token punctuation\">[</span>pb<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        uf<span class=\"token punctuation\">.</span><span class=\"token function\">unite</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cost <span class=\"token operator\">-=</span> c<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">for</span> a <span class=\"token keyword\">in</span> ans<span class=\"token punctuation\">.</span><span class=\"token function\">iter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">rev</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n</div>\n</details>\n<h2 id=\"所感\"><a href=\"#所感\">所感</a></h2>\n<p>unite by rankとunite by sizeは本質的には同じなので落ち着いて対処したかった.</p>\n<p>またrankに符号付き整数を用いて, 正負でsize or rankを表すテクもあることを知った.</p>\n<div class=\"remark-container info\"><div class=\"remark-container__title\">TODO</div><p>basic (<a href=\"https://atcoder.jp/contests/abc075/tasks/abc075_c\" rel=\"nofollow\">Bridge/ABC075</a>)<br>\nweighted(Potential) Union-Find (<a href=\"https://atcoder.jp/contests/abc087/tasks/arc090_b\" rel=\"nofollow\">People on a line/ABC087</a>)<br>\n永続UF (<a href=\"https://agc002.contest.atcoder.jp/tasks/agc002_d\" rel=\"nofollow\">Stamp Rally/AGC002</a>)<br>\nわからん (<a href=\"https://agc015.contest.atcoder.jp/tasks/agc015_c\" rel=\"nofollow\">Nuske vs Phantom Thnook/AGC015</a>)</p></div>\n<section data-footnotes=\"\" class=\"footnotes\"><h2 class=\"sr-only\" id=\"footnote-label\"><a href=\"#footnote-label\">Footnotes</a></h2>\n<ol>\n<li id=\"user-content-fn-1\">\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>α</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>A</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo separator=\"true\">,</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\alpha^{-1}(n) = Ackerman(n, n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mord mathnormal\">man</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>. 経路圧縮とrankどちらかのみの場合はならし計算量<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>. <a href=\"#user-content-fnref-1\" data-footnote-backref=\"\" aria-label=\"Back to reference 1\" class=\"data-footnote-backref\">↩</a></p>\n</li>\n</ol>\n</section>","description":"rankしかもってなかった","commits":[{"title":"update remark-custom-container to 1.2.0","date":"2022-11-27 00:25:35","hash":"897b048f","diff":"<div class=\"remark-highlight\"><pre data-file=\"897b048f.patch\" class=\"language-git language-diff\"><code class=\"language-git\"><span class=\"token commit-sha1\">commit 897b048fe31450b5d4f6545855125b76492f9066</span>\nAuthor: koka &#x26;<a href=\"mailto:lt;koka.code@gmail.com\" class=\"token email-link\">lt;koka.code@gmail.com</a>&#x26;gt;\nDate:   Sun Nov 27 00:25:35 2022 +0900\n\n  update remark-custom-container to 1.2.0\n  \n  fix\n\ndiff --git a/_posts/2019-03-08-unionfind.md b/_posts/2019-03-08-unionfind.md\nindex dc993c9..a040a25 100644\n<span class=\"token deleted\">--- a/_posts/2019-03-08-unionfind.md</span>\n<span class=\"token inserted\">+++ b/_posts/2019-03-08-unionfind.md</span>\n@@ -102,8 +102,10 @@ Union-Findでは要素を統合することはできても分割操作は行え\n\nが, Union-Findで集合の要素数を持つケースを初めて見たのでやや手間取った. 本番では構造体に要素数`siz`を`Vec`で保持させて$unite$時に更新してなんとかなった.\n\n<span class=\"token deleted\">-::: tip 追記</span>\n<span class=\"token inserted\">+::: info 追記</span>\n<span class=\"token inserted\">+</span>\nこの辺が存在した場合の連結する頂点数を考えると, $n * (n - 1) / 2$なのでここから引いてくと楽.\n<span class=\"token inserted\">+</span>\n:::\n\n&#x26;lt;details&#x26;gt;\n@@ -153,11 +155,13 @@ unite by rankとunite by sizeは本質的には同じなので落ち着いて対\n\nまたrankに符号付き整数を用いて, 正負でsize or rankを表すテクもあることを知った.\n\n<span class=\"token deleted\">-::: tip TODO</span>\n<span class=\"token inserted\">+::: info TODO</span>\n<span class=\"token inserted\">+</span>\nbasic ([Bridge/ABC075](<a href=\"https://atcoder.jp/contests/abc075/tasks/abc075_c\" class=\"token url-link\" rel=\"nofollow\">https://atcoder.jp/contests/abc075/tasks/abc075_c</a>))  \nweighted(Potential) Union-Find ([People on a line/ABC087](<a href=\"https://atcoder.jp/contests/abc087/tasks/arc090_b\" class=\"token url-link\" rel=\"nofollow\">https://atcoder.jp/contests/abc087/tasks/arc090_b</a>))  \n永続UF ([Stamp Rally/AGC002](<a href=\"https://agc002.contest.atcoder.jp/tasks/agc002_d\" class=\"token url-link\" rel=\"nofollow\">https://agc002.contest.atcoder.jp/tasks/agc002_d</a>))  \nわからん ([Nuske vs Phantom Thnook/AGC015](<a href=\"https://agc015.contest.atcoder.jp/tasks/agc015_c\" class=\"token url-link\" rel=\"nofollow\">https://agc015.contest.atcoder.jp/tasks/agc015_c</a>))\n<span class=\"token inserted\">+</span>\n:::\n\n[^1]: $\\alpha^{-1}(n) = Ackerman(n, n)$. 経路圧縮とrankどちらかのみの場合はならし計算量$O(log n)$.\n</code></pre></div>"},{"title":"copy md","date":"2021-01-30 22:18:17","hash":"35b550ae","diff":"<div class=\"remark-highlight\"><pre data-file=\"35b550ae.patch\" class=\"language-git language-diff\"><code class=\"language-git\"><span class=\"token commit-sha1\">commit 35b550ae83af4efaeadf33471c8ca8a32c1079c8</span>\nAuthor: koka &#x26;<a href=\"mailto:lt;koka.code@gmail.com\" class=\"token email-link\">lt;koka.code@gmail.com</a>&#x26;gt;\nDate:   Sat Jan 30 22:18:17 2021 +0900\n\n  copy md\n\ndiff --git a/_posts/2019-03-08-unionfind.md b/_posts/2019-03-08-unionfind.md\nnew file mode 100644\nindex 0000000..dc993c9\n<span class=\"token deleted\">--- /dev/null</span>\n<span class=\"token inserted\">+++ b/_posts/2019-03-08-unionfind.md</span>\n<span class=\"token coord\">@@ -0,0 +1,163 @@</span>\n<span class=\"token inserted\">+---</span>\n<span class=\"token inserted\">+title: UnionFind</span>\n<span class=\"token inserted\">+date: 2019-03-08</span>\n<span class=\"token inserted\">+categories:</span>\n<span class=\"token inserted\">+- Competitive Programming</span>\n<span class=\"token inserted\">+tags:</span>\n<span class=\"token inserted\">+- Graph</span>\n<span class=\"token inserted\">+- TODO</span>\n<span class=\"token inserted\">+description: rankしかもってなかった</span>\n<span class=\"token inserted\">+---</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+[AtCoder Beginners Contest 120](https://atcoder.jp/contests/abc120) で連結成分のsizeを計算するdisjoint-setの問題が出題された.</span>\n<span class=\"token inserted\">+それまでrankを用いたUnion-Findしか経験がなかったので, この機会にまとめる.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+## Union-Find</span>\n<span class=\"token inserted\">+Union-Findは要素が同一の集合に含まれるかどうかを判定するデータ構造.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+| Query      | Process       |</span>\n<span class=\"token inserted\">+|------------|---------------|</span>\n<span class=\"token inserted\">+| unite(x, y)|X(x $\\in$ X)とY(y $\\in$ Y)をマージする |</span>\n<span class=\"token inserted\">+| same(x, y) |X == Y か判定する   |</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+の操作を</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+各要素を1つのノード, 集合を木と表現する.</span>\n<span class=\"token inserted\">+要素が同一の集合に含まれる場合, それらの要素は同一の木のノードである.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+上記操作をならし計算量$O(\\alpha(n))$で行う[^1]ためのマージ戦略が以下の経路圧縮とrankである.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+### 経路圧縮</span>\n<span class=\"token inserted\">+要素が同一の木のノードであるか判定する場合, 各要素のrootが同一かどうか見ればよい.</span>\n<span class=\"token inserted\">+ただその場合木の高さだけ再帰的に親ノードを辿る必要がある.  </span>\n<span class=\"token inserted\">+そこで, 親ノードを調べる際に調べたノードをrootに直接つなぎ直すことで,次回以降の判定時の計算量を$O(1)$に削減する.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+### Rank</span>\n<span class=\"token inserted\">+$unite()$操作時に木の高さが高い方を親として, 低い方を高い方に繋げるようにする.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+ここで, 経路圧縮と併用する場合には圧縮前の高さでrankを持つ必要がある.</span>\n<span class=\"token inserted\">+経路圧縮は$find()$操作時に行うため, $unite()$の段階では必ずしも木の高さが$1$となっている保証はない.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+&#x26;lt;details&#x26;gt;</span>\n<span class=\"token inserted\">+&#x26;lt;summary&#x26;gt;以下は経路圧縮のみの実装例.&#x26;lt;/summary&#x26;gt;</span>\n<span class=\"token inserted\">+&#x26;lt;div&#x26;gt;</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+\\```rust</span>\n<span class=\"token inserted\">+struct UnionFind {</span>\n<span class=\"token inserted\">+  par: Vec&#x26;lt;usize&#x26;gt;,</span>\n<span class=\"token inserted\">+}</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+impl UnionFind {</span>\n<span class=\"token inserted\">+  fn new(n: usize) -&#x26;gt; Self {</span>\n<span class=\"token inserted\">+    UnionFind {</span>\n<span class=\"token inserted\">+      par: (0..n).collect(),</span>\n<span class=\"token inserted\">+    }</span>\n<span class=\"token inserted\">+  }</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  fn unite(&#x26;mut self, x: usize, y: usize) {</span>\n<span class=\"token inserted\">+    let px = self.find(x);</span>\n<span class=\"token inserted\">+    let py = self.find(y);</span>\n<span class=\"token inserted\">+    if px == py { return; }</span>\n<span class=\"token inserted\">+    self.par[py] = px;</span>\n<span class=\"token inserted\">+  }</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  fn same(&#x26;mut self, x: usize, y: usize) -&#x26;gt; bool {</span>\n<span class=\"token inserted\">+    self.find(x) == self.find(y)</span>\n<span class=\"token inserted\">+  }</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  fn find(&#x26;mut self, x: usize) -&#x26;gt; usize {</span>\n<span class=\"token inserted\">+    if self.par[x] == x { x }</span>\n<span class=\"token inserted\">+    else {</span>\n<span class=\"token inserted\">+      // 経路圧縮</span>\n<span class=\"token inserted\">+      let p = self.par[x];</span>\n<span class=\"token inserted\">+      self.par[x] = self.find(p);</span>\n<span class=\"token inserted\">+      self.par[x]</span>\n<span class=\"token inserted\">+    }</span>\n<span class=\"token inserted\">+  }</span>\n<span class=\"token inserted\">+}</span>\n<span class=\"token inserted\">+\\```</span>\n<span class=\"token inserted\">+&#x26;lt;/div&#x26;gt;</span>\n<span class=\"token inserted\">+&#x26;lt;/details&#x26;gt;</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+## [Decayed Bridges](https://atcoder.jp/contests/abc120/tasks/abc120_d)</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+本題.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+$n$頂点$m$辺の無向単純グラフの辺$i \\in M$を順番に取り除いたとき, 時刻$i$でアクセスできない頂点が何組あるか.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+### かんがえたこと</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+Union-Findでは要素を統合することはできても分割操作は行えない.</span>\n<span class=\"token inserted\">+辺を除去する操作を考える場合にはグラフ全体を保持する必要が出てきてしまう. でも$n, m \\leq 10^5$で隣接グラフを持つのはエグいし連結判定が厳しい.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+では操作を巻き戻すとどうなるかを考えた.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+まず辺をすべて取り除いた状態から開始し，辺を追加していく.  </span>\n<span class=\"token inserted\">+このアプローチならUnion-Findで管理できる.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+辺を追加することで$a$頂点と$b$頂点が新たに連結されたとすると, アクセスできる頂点ペアは$a * b$個増える.</span>\n<span class=\"token inserted\">+この連結された頂点の増加判定は$same$操作を$unite$操作の前後に行うことで行える.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+が, Union-Findで集合の要素数を持つケースを初めて見たのでやや手間取った. 本番では構造体に要素数`siz`を`Vec`で保持させて$unite$時に更新してなんとかなった.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+::: tip 追記</span>\n<span class=\"token inserted\">+この辺が存在した場合の連結する頂点数を考えると, $n * (n - 1) / 2$なのでここから引いてくと楽.</span>\n<span class=\"token inserted\">+:::</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+&#x26;lt;details&#x26;gt;</span>\n<span class=\"token inserted\">+&#x26;lt;summary&#x26;gt;解答&#x26;lt;/summary&#x26;gt;</span>\n<span class=\"token inserted\">+&#x26;lt;div&#x26;gt;</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+\\```rust</span>\n<span class=\"token inserted\">+fn main() {</span>\n<span class=\"token inserted\">+    let (n, m) = {</span>\n<span class=\"token inserted\">+        let i = read::&#x26;lt;usize&#x26;gt;();</span>\n<span class=\"token inserted\">+        (i[0], i[1])</span>\n<span class=\"token inserted\">+    };</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+    let mut ab = Vec::new();</span>\n<span class=\"token inserted\">+    for _ in 0..m {</span>\n<span class=\"token inserted\">+        let (a, b) = {</span>\n<span class=\"token inserted\">+            let i = read::&#x26;lt;usize&#x26;gt;();</span>\n<span class=\"token inserted\">+            (i[0], i[1])</span>\n<span class=\"token inserted\">+        };</span>\n<span class=\"token inserted\">+        ab.push((a, b));</span>\n<span class=\"token inserted\">+    }</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+    let mut uf = UnionFind::new(n + 1);</span>\n<span class=\"token inserted\">+    let mut cost = n * (n - 1) / 2;</span>\n<span class=\"token inserted\">+    let mut ans = Vec::new();</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+    for (a, b) in ab.into_iter().rev() {</span>\n<span class=\"token inserted\">+        ans.push(cost);</span>\n<span class=\"token inserted\">+        if uf.same(a, b) { continue; }</span>\n<span class=\"token inserted\">+        let pa = uf.find(a);</span>\n<span class=\"token inserted\">+        let pb = uf.find(b);</span>\n<span class=\"token inserted\">+        let c = uf.siz[pa] * uf.siz[pb];</span>\n<span class=\"token inserted\">+        uf.unite(a, b);</span>\n<span class=\"token inserted\">+        cost -= c;</span>\n<span class=\"token inserted\">+    }</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+    for a in ans.iter().rev() {</span>\n<span class=\"token inserted\">+        println!(\"{}\", a);</span>\n<span class=\"token inserted\">+    }</span>\n<span class=\"token inserted\">+}</span>\n<span class=\"token inserted\">+\\```</span>\n<span class=\"token inserted\">+&#x26;lt;/div&#x26;gt;</span>\n<span class=\"token inserted\">+&#x26;lt;/details&#x26;gt;</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+## 所感</span>\n<span class=\"token inserted\">+unite by rankとunite by sizeは本質的には同じなので落ち着いて対処したかった.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+またrankに符号付き整数を用いて, 正負でsize or rankを表すテクもあることを知った.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+::: tip TODO</span>\n<span class=\"token inserted\">+basic ([Bridge/ABC075](https://atcoder.jp/contests/abc075/tasks/abc075_c))  </span>\n<span class=\"token inserted\">+weighted(Potential) Union-Find ([People on a line/ABC087](https://atcoder.jp/contests/abc087/tasks/arc090_b))  </span>\n<span class=\"token inserted\">+永続UF ([Stamp Rally/AGC002](https://agc002.contest.atcoder.jp/tasks/agc002_d))  </span>\n<span class=\"token inserted\">+わからん ([Nuske vs Phantom Thnook/AGC015](https://agc015.contest.atcoder.jp/tasks/agc015_c))</span>\n<span class=\"token inserted\">+:::</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+[^1]: $\\alpha^{-1}(n) = Ackerman(n, n)$. 経路圧縮とrankどちらかのみの場合はならし計算量$O(log n)$.</span>\n</code></pre></div>"}],"publishedAt":"2019-03-08","updatedAt":"2022-11-27"}},"__N_SSG":true}